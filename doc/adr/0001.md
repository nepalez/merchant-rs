# ADR-0001: Bank Routing Number Design

## Context
The core crate requires a canonical type to represent bank account details for ACH, SEPA, and other non-card payment rails. The field routing_number must accommodate various country-specific formats, such as US ABA, European SWIFT/BIC, UK Sort Codes, and Australian BSB.

The debate is whether to use a strictly-typed enum (e.g., `Routing::ABA(String)`) or a simpler `String` in the canonical core type.

## Decision
The `routing_number` field within `BankAccountDetails` will be defined as a plain `String`:

```rust
pub struct BankAccountDetails {
    // ...
    pub routing_number: String,
    // ...
}
```
The core crate will **NOT** use an enum to strictly type the routing number format.

## Consequences

### Pros
* **Maximum Universality**: The core type remains agnostic to specific geographic bank formats, preventing type inflation and maintaining stability when new national routing standards emerge.
* **Serialization Simplicity**: Direct compatibility with standard JSON serialization ("routing_number": "...") without custom serde logic.
* **Decoupling**: The core is decoupled from the complex and volatile business logic of country-specific banking regulation.

### Cons
* No Compile-Time Validation: The core cannot enforce the correct format (e.g., _9-digit ABA, 8-11 character SWIFT_).

### Action: Delegation of Responsibility
The complex, but largely universal, validation logic for these formats must be extracted into a separate, reusable crate (e.g., `merchant-rs-validator`).

However, the responsibility for format identification and initiation of validation falls to the Adapter layer:
* The Adapter must infer the required format (e.g., ABA if the transaction is targeted at the US).
* The Adapter then calls the `merchant-rs-validator` with the explicit format type (e.g., `validator::validate_aba(&raw_number)`).

This preserves the purity of the core data contract while allowing universal validation logic to be reusable.

### Impact
The core crate remains small, stable, and focused on its data contract.
Domain-specific complexity is delegated to the adapter implementations, where it is best managed.
